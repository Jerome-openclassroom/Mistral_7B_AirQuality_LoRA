# -*- coding: utf-8 -*-
"""conversion_jsonl_SQL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ISkzjyggNdTgqn9IncCLP0Knw8-yH5fa
"""

import json
import re

# ------------------------------------------------------------
# Fonctions d'extraction des champs depuis le texte brut
# ------------------------------------------------------------

def extract_conditions(content):
    """
    Extrait les conditions environnementales / météo / qualité de l'air
    à partir du message 'user'. Retourne un dict prêt à être inséré en SQL.
    Certaines valeurs sont renvoyées sous forme de chaînes déjà quotées,
    ou sous forme 'NULL' si absentes.
    """
    if not isinstance(content, str):
        return {
            'temperature_range': 'NULL',
            'humidity': 'NULL',
            'thermal_inversion': 'NULL',
            'pollens_level': 'NULL',
            'aqi': 'NULL',
            'strong_wind': 'NULL',
            'heavy_rain': 'NULL'
        }

    fields = {
        # Température = 10-20°C
        'temperature_range': (
            f"'{re.search(r'Température = ([^,]+)', content).group(1).strip()}'"
            if re.search(r'Température = ([^,]+)', content) else 'NULL'
        ),

        # Humidité = >70%
        'humidity': (
            f"'{re.search(r'Humidité = ([^,]+)', content).group(1).strip()}'"
            if re.search(r'Humidité = ([^,]+)', content) else 'NULL'
        ),

        # Inversion thermique = oui / non -> booléen 1/0
        'thermal_inversion': (
            '1' if re.search(r'Inversion thermique = oui', content)
            else '0'
        ),

        # Pollens = élevé / moyen / faible
        'pollens_level': (
            f"'{re.search(r'Pollens = ([^,]+)', content).group(1).strip()}'"
            if re.search(r'Pollens = ([^,]+)', content) else 'NULL'
        ),

        # IQA = 4
        'aqi': (
            re.search(r'IQA = (\d+)', content).group(1)
            if re.search(r'IQA = (\d+)', content) else 'NULL'
        ),

        # Vent fort = oui / non -> booléen 1/0
        'strong_wind': (
            '1' if re.search(r'Vent fort = oui', content)
            else '0'
        ),

        # Pluie forte = oui / non -> booléen 1/0
        'heavy_rain': (
            '1' if re.search(r'Pluie forte = oui', content)
            else '0'
        )
    }

    return fields


def extract_assistant_response(content):
    """
    Extrait les évaluations santé à partir du message 'assistant'.
    Retourne un dict prêt à être inséré en SQL.
    """
    if not isinstance(content, str):
        return {
            'allergy_level': 'NULL',
            'cardiovascular_risk': 'NULL'
        }

    fields = {
        # Niveau d’allergie : élevé.
        'allergy_level': (
            f"'{re.search(r'Niveau d’allergie : ([^.]+)', content).group(1).strip()}'"
            if re.search(r'Niveau d’allergie : ([^.]+)', content) else 'NULL'
        ),

        # Sensibilité cardiovasculaire : faible.
        'cardiovascular_risk': (
            f"'{re.search(r'Sensibilité cardiovasculaire : ([^.]+)', content).group(1).strip()}'"
            if re.search(r'Sensibilité cardiovasculaire : ([^.]+)', content) else 'NULL'
        )
    }

    return fields


# ------------------------------------------------------------
# Fonction principale : génération du fichier SQL
# ------------------------------------------------------------

def generate_sql_from_jsonl(
    jsonl_path: str,
    sql_output_path: str = "lyra_air_sante_import.sql"
):
    """
    Lit un fichier JSONL de type:
    {
      "messages": [
        {"role": "user", "content": "..."},
        {"role": "assistant", "content": "..."}
      ]
    }

    Crée un fichier .sql qui :
    1. Déclare la table air_sante_conversations
    2. Insère les données (une ligne par message user ou assistant)
    """

    with open(sql_output_path, 'w', encoding='utf-8') as f_sql:

        # 1. Ecriture du schéma SQL (DROP TABLE + CREATE TABLE)
        f_sql.write(
            """-- Création de la table
DROP TABLE IF EXISTS air_sante_conversations;
CREATE TABLE air_sante_conversations (
    id INT AUTO_INCREMENT PRIMARY KEY,
    conversation_id INT NOT NULL,
    role VARCHAR(20) NOT NULL,
    content TEXT,
    temperature_range VARCHAR(20),
    humidity VARCHAR(10),
    thermal_inversion BOOLEAN,
    pollens_level VARCHAR(10),
    aqi INT,
    strong_wind BOOLEAN,
    heavy_rain BOOLEAN,
    allergy_level VARCHAR(20),
    cardiovascular_risk VARCHAR(20),
    INDEX (conversation_id),
    INDEX (role)
);

"""
        )

        # 2. Lecture du dataset JSONL
        with open(jsonl_path, 'r', encoding='utf-8') as f_in:
            for conversation_id, line in enumerate(f_in, start=1):
                entry = json.loads(line)

                # 3. Pour chaque message (user / assistant), générer un INSERT
                for message in entry["messages"]:
                    role = message.get("role", "")
                    content = message.get("content", "")

                    # on échappe les quotes simples dans le texte pour ne pas casser le SQL
                    safe_content = content.replace("'", "''")

                    if role == "user":
                        extracted = extract_conditions(content)

                        insert_stmt = f"""
INSERT INTO air_sante_conversations (
    conversation_id, role, content,
    temperature_range, humidity, thermal_inversion,
    pollens_level, aqi, strong_wind, heavy_rain,
    allergy_level, cardiovascular_risk
) VALUES (
    {conversation_id}, 'user', '{safe_content}',
    {extracted['temperature_range']}, {extracted['humidity']}, {extracted['thermal_inversion']},
    {extracted['pollens_level']}, {extracted['aqi']}, {extracted['strong_wind']}, {extracted['heavy_rain']},
    NULL, NULL
);

"""
                        f_sql.write(insert_stmt)

                    else:
                        extracted = extract_assistant_response(content)

                        insert_stmt = f"""
INSERT INTO air_sante_conversations (
    conversation_id, role, content,
    temperature_range, humidity, thermal_inversion,
    pollens_level, aqi, strong_wind, heavy_rain,
    allergy_level, cardiovascular_risk
) VALUES (
    {conversation_id}, 'assistant', '{safe_content}',
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    {extracted['allergy_level']}, {extracted['cardiovascular_risk']}
);

"""
                        f_sql.write(insert_stmt)

    # 4. Message final
    print(f"✅ Fichier SQL généré : {sql_output_path}")


# ------------------------------------------------------------
# Point d'entrée (exécution directe)
# ------------------------------------------------------------

if __name__ == "__main__":
    # Nom du fichier source JSONL
    INPUT_JSONL = "lyra_air_sante_valid_120.jsonl"

    # Nom du fichier SQL à générer
    OUTPUT_SQL = "lyra_air_sante_import.sql"

    generate_sql_from_jsonl(INPUT_JSONL, OUTPUT_SQL)